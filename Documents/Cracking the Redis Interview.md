



### 使用过Redis做异步队列么，你是怎么用的？

 一般使用list结构队列，`rpush`生产消息，`lpop`消费消息，`lpop`没有消息的时候，适当的sleep一会。如果不用sleep呢，还有一个指令是`blpop`,在没有消息来的时候，会阻塞消息直到到来消息。

### 能不能生产一次消费多次呢？

使用`pub/sub`主题订阅模式，可以实现1:N的消息队列，那这样会有什么样的缺点呢，在消费者下线的时候，生产的消息会丢失。得使用专业的消息队列，如`RocketMQ`

### Redis如何实现延时队列？

使用zset, 那时间戳作为score，消息内容为key,调用zadd来产生消息，消费者使用zrangebyscore来获取N秒之前的数据，进行轮询处理。

### Redis是怎么持久化的？服务主从数据怎么交互的？

RDB做镜像全量持久化，AOF做增量持久化，这里是因为RDB比较费时，不够实时，在停机的时候，会导致大量的数据丢失，所以AOF结合使用。在Redis实例重启时，会使用RDB持久化文件重新构建内存，再使用AOF重放近期的操作指令，来实现恢复之前的状态。优先加载AOF，再加载RDB。

### 如果突然机器掉电会怎样？

这取决于AOF的sync属性，如果性能要求不高，可以每条指令都同步，但如果要求性能要求高，可以使用定时，比如1s同步一次，这样只会丢失1s的数据。

### RDB的原理是什么？

主要是两个点，fork和cow, fork是指Redis通过创建子进程来进行RDB操作，而cow指的是copy on write, 子进程创建后，父进程共享数据段，父进程继续提供读写服务，写胀的页面数据会逐渐和子进程分离开来。

### Pipeline有什么好处，为什么要用pipeline？

可以将多次IO往返的时间缩减为一次。

### Redis的同步机制了解么？

Redis可以使用主从同步，丛丛同步。第一次同步时，主节点做一次`bgsave`,并同时将后续的操作记录保存到内存buffer，完成后将RDB文件全量同步到复制节点，复制节点完成后，将RDB镜像加载到内存。这个时候，将主节点记录的操作记录同步到复制节点进行重放，后续的增量可以使用AOF方式，这个过程有点类似MySQL的`binlog`.

### 是否使用过Redis集群，集群的高可用怎么保证，集群的原理是什么？

Redis Sentinal 着眼于高可用，就是在master宕机之后，会自动将slave提升为master.

Redis Cluster 着眼于可扩展，就是在单个Redis内存不足时，使用cluster进行分片存储。

### Redis雪崩了解么？

雪崩是指缓存key大面积失效，处理雪崩的话，想Redis存数据的时候，将key的失效时间加一个随机值。

`setRedis(key, value, Math.random() *10000);`

### 缓存穿透和击穿，跟雪崩的区别

缓存穿透就是缓存和数据库中都没有数据，而用户不断发起请求，如发起一个id=-1的请求，可以发起对数据库的攻击。

而缓存击穿是指一个特别活跃的key瞬间失效了，有大并发的情况下，当key失效的瞬间，击穿缓存。

### 缓存穿透怎么解决

缓存穿透会在接口层做参数校验。

使用布隆过滤器(Bloom Fliter), 这个能很好的防止缓存穿透的发生，其作用就是快速的去内存中查询key是否存在。缓存击穿的话，设置key不过期或者加锁。

一般的解决方案是Redis高可用，使用主从+哨兵，Redis cluster避免全面崩溃。



### Redis的优点和特性

Redis使用单线程处理请求，单线程可以避免线程上下文切换产生的代价。

- Redis支持持久化，所以Redis不仅可以用作缓存，还可以用作NoSql数据库。
- 提供多种数据结构。
- Redis提供主从同步，以及Cluster可扩展方案。

### 淘汰策略

- **allkeys-random**: 回收随机的键使得新添加的数据有空间存放。
- **allkeys-lru**:尝试回收最少使用的key，使得新添加的数据有地方存放。
- **volatile-lru**:尝试回收最少使用的key，但仅限于过期集合的key，使得新添加的数据有空间存放。
- **volatile-random**：随机的回收使用的key，仅限于过期集合中的key。
- **volatile-ttl**：优先回收存活时间(ttl)较短的key。

### 数据一致性问题

### 缓存更新方式

如果数据源是db,可以在db更新完后，直接更新缓存，如果数据源是其他服务，可以对key设置过期时间，更新失效的数据。









