# 大并发服务器架构

## 简介

服务器性能四大杀手

1. 数据拷贝, 缓存

2. 环境切换该不该用多线程，单线程好还是多线程好，单核服务器（采用状态机编程，效率最佳）

3. 内存分配 内存池
4. 锁竞争

## poll原理

1. 你能描述一下poll函数原理么？

   ```c++
   #include <poll.h>
   
   int poll(struct pollfd *fds, nfds_t nfds, int timeout);
   
   struct pollfd {
   	int   fd;	/* file descriptor */
   	short events;	/* requested events */
   	short revents;	/* returned events */
   };
   ```

2. 你知道为什么要忽略`signal(SIGPIPE, SIG_IGN);`?

   如果客户端关闭套接字close，而服务器调用了一次`write`,服务器会接收一个RST segment (TCP传输层)

   如果服务器端再次调用了`write`，这个时候会产生`SIGPIPE`信号，而`SIGPIPE`默认的处理方式是退出程序。

3. 你能说说你对`TIME_WAIT`状态么，对大并发服务器的影响？

   如果服务器主动断开连接，先于client端调用close，服务端就会进入`TIME_WAIT`

   协议设计上，应该让客户端主动断开连接，这样就把`TIME_WAIT`状态分散到大量的客户端。服务器端也要有个机制来踢掉不活跃的连接。

4. 你知道为什么要在创建套接字的时候设置`SOCK_NONBLOCK|SOCK_CLOSEC`呢？

5. Poll关注的事件是什么呢？

6. 你知道`accept`和`accept4`有什么区别么？

7. 可以简单的说一下实现一个`echo server`的过程么？

## poll使用基本流程

1. `read`可能并没有把`connfd`所对应的接收缓冲区的数据够都读完，那么connfd仍然是活跃的，我们应该将读到的数据保存在`connfd`保存在应用层的缓冲区。同理`write`发送的时候，我们也应该有一个应用层的缓冲区，`POLLOUT`事件。

2. 如果没有事件，但是我们一直关注`POLLOUT`事件会出现什么现象呢？

   会出现`busy loop`忙等待。

3. epoll和poll有什么区别呢？

4. `accept`返回EMFILE的处理？







